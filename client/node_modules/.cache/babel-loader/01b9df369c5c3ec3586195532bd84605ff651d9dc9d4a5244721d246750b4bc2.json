{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst WEBSOCKET_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:5000/ws';\nexport const useWebSocket = (url = WEBSOCKET_URL) => {\n  _s();\n  const [connectionStatus, setConnectionStatus] = useState('Connecting');\n  const [lastMessage, setLastMessage] = useState(null);\n  const [messageHistory, setMessageHistory] = useState([]);\n  const ws = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectInterval = 3000;\n  const connect = useCallback(() => {\n    try {\n      ws.current = new WebSocket(url);\n      ws.current.onopen = () => {\n        console.log('WebSocket Connected');\n        setConnectionStatus('Connected');\n        reconnectAttempts.current = 0;\n      };\n      ws.current.onmessage = event => {\n        const message = {\n          data: event.data,\n          timestamp: new Date().toISOString()\n        };\n        setLastMessage(message);\n        setMessageHistory(prev => [...prev.slice(-99), message]); // Keep last 100 messages\n      };\n      ws.current.onclose = event => {\n        console.log('WebSocket Disconnected:', event.code, event.reason);\n        setConnectionStatus('Disconnected');\n\n        // Attempt to reconnect if not intentionally closed\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          setConnectionStatus(`Reconnecting (${reconnectAttempts.current}/${maxReconnectAttempts})`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectInterval);\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\n          setConnectionStatus('Failed');\n        }\n      };\n      ws.current.onerror = error => {\n        console.error('WebSocket Error:', error);\n        setConnectionStatus('Error');\n      };\n    } catch (error) {\n      console.error('WebSocket Connection Error:', error);\n      setConnectionStatus('Error');\n    }\n  }, [url]);\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (ws.current) {\n      ws.current.close(1000, 'Intentional disconnect');\n    }\n  }, []);\n  const sendMessage = useCallback(message => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      ws.current.send(JSON.stringify(message));\n      return true;\n    } else {\n      console.warn('WebSocket is not connected. Message not sent:', message);\n      return false;\n    }\n  }, []);\n  const getReadyState = useCallback(() => {\n    if (!ws.current) return WebSocket.CLOSED;\n    return ws.current.readyState;\n  }, []);\n\n  // Connect on mount\n  useEffect(() => {\n    connect();\n\n    // Cleanup on unmount\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Ping to keep connection alive\n  useEffect(() => {\n    const pingInterval = setInterval(() => {\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: 'ping',\n          timestamp: new Date().toISOString()\n        });\n      }\n    }, 30000); // Ping every 30 seconds\n\n    return () => clearInterval(pingInterval);\n  }, [sendMessage]);\n  return {\n    connectionStatus,\n    lastMessage,\n    messageHistory,\n    sendMessage,\n    connect,\n    disconnect,\n    getReadyState\n  };\n};\n_s(useWebSocket, \"nBQiAG34ILhPFg5bMih7qbUA/oM=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","WEBSOCKET_URL","process","env","REACT_APP_WS_URL","useWebSocket","url","_s","connectionStatus","setConnectionStatus","lastMessage","setLastMessage","messageHistory","setMessageHistory","ws","reconnectTimeoutRef","reconnectAttempts","maxReconnectAttempts","reconnectInterval","connect","current","WebSocket","onopen","console","log","onmessage","event","message","data","timestamp","Date","toISOString","prev","slice","onclose","code","reason","setTimeout","onerror","error","disconnect","clearTimeout","close","sendMessage","readyState","OPEN","send","JSON","stringify","warn","getReadyState","CLOSED","pingInterval","setInterval","type","clearInterval"],"sources":["C:/Users/liamj/Desktop/AI/LeadScraper/client/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\r\n\r\nconst WEBSOCKET_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:5000/ws';\r\n\r\nexport const useWebSocket = (url = WEBSOCKET_URL) => {\r\n  const [connectionStatus, setConnectionStatus] = useState('Connecting');\r\n  const [lastMessage, setLastMessage] = useState(null);\r\n  const [messageHistory, setMessageHistory] = useState([]);\r\n  const ws = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttempts = useRef(0);\r\n  const maxReconnectAttempts = 5;\r\n  const reconnectInterval = 3000;\r\n\r\n  const connect = useCallback(() => {\r\n    try {\r\n      ws.current = new WebSocket(url);\r\n      \r\n      ws.current.onopen = () => {\r\n        console.log('WebSocket Connected');\r\n        setConnectionStatus('Connected');\r\n        reconnectAttempts.current = 0;\r\n      };\r\n\r\n      ws.current.onmessage = (event) => {\r\n        const message = {\r\n          data: event.data,\r\n          timestamp: new Date().toISOString()\r\n        };\r\n        \r\n        setLastMessage(message);\r\n        setMessageHistory(prev => [...prev.slice(-99), message]); // Keep last 100 messages\r\n      };\r\n\r\n      ws.current.onclose = (event) => {\r\n        console.log('WebSocket Disconnected:', event.code, event.reason);\r\n        setConnectionStatus('Disconnected');\r\n        \r\n        // Attempt to reconnect if not intentionally closed\r\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\r\n          reconnectAttempts.current++;\r\n          setConnectionStatus(`Reconnecting (${reconnectAttempts.current}/${maxReconnectAttempts})`);\r\n          \r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connect();\r\n          }, reconnectInterval);\r\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\r\n          setConnectionStatus('Failed');\r\n        }\r\n      };\r\n\r\n      ws.current.onerror = (error) => {\r\n        console.error('WebSocket Error:', error);\r\n        setConnectionStatus('Error');\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('WebSocket Connection Error:', error);\r\n      setConnectionStatus('Error');\r\n    }\r\n  }, [url]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (reconnectTimeoutRef.current) {\r\n      clearTimeout(reconnectTimeoutRef.current);\r\n    }\r\n    \r\n    if (ws.current) {\r\n      ws.current.close(1000, 'Intentional disconnect');\r\n    }\r\n  }, []);\r\n\r\n  const sendMessage = useCallback((message) => {\r\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\r\n      ws.current.send(JSON.stringify(message));\r\n      return true;\r\n    } else {\r\n      console.warn('WebSocket is not connected. Message not sent:', message);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  const getReadyState = useCallback(() => {\r\n    if (!ws.current) return WebSocket.CLOSED;\r\n    return ws.current.readyState;\r\n  }, []);\r\n\r\n  // Connect on mount\r\n  useEffect(() => {\r\n    connect();\r\n    \r\n    // Cleanup on unmount\r\n    return () => {\r\n      disconnect();\r\n    };\r\n  }, [connect, disconnect]);\r\n\r\n  // Ping to keep connection alive\r\n  useEffect(() => {\r\n    const pingInterval = setInterval(() => {\r\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\r\n        sendMessage({ type: 'ping', timestamp: new Date().toISOString() });\r\n      }\r\n    }, 30000); // Ping every 30 seconds\r\n\r\n    return () => clearInterval(pingInterval);\r\n  }, [sendMessage]);\r\n\r\n  return {\r\n    connectionStatus,\r\n    lastMessage,\r\n    messageHistory,\r\n    sendMessage,\r\n    connect,\r\n    disconnect,\r\n    getReadyState\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}